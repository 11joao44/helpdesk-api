# Define a ordem de execu√ß√£o dos est√°gios
stages:
  - build
  - deploy

workflow:
  rules:
    # Regra para verificar se a vari√°vel EXECUTE_PIPELINE √© definida como "true"
    - if: '$EXECUTE_PIPELINE == "true"'
    - when: never  # N√£o executa por padr√£o a cada commit

# EST√ÅGIO 1: Construir as imagens Docker (frontend e backend) e enviar para o Registry
build_images: # MUDAN√áA: Renomeado para refletir a constru√ß√£o de m√∫ltiplas imagens
  stage: build
  tags:
    - run-cgr-dind
  
  image: docker:20.10.16
  
  services:
    - name: docker:20.10.16-dind
      alias: docker # O alias √© importante para o DOCKER_HOST
      # Adiciona a flag para permitir a conex√£o HTTP com seu registry
      command: ["--insecure-registry=gitlab.carvalima.com.br:5050"]
  
  # --- SE√á√ÉO CR√çTICA QUE ESTAVA FALTANDO ---
  variables:
    # Aponta o cliente Docker para o servi√ßo 'dind' na rede
    DOCKER_HOST: tcp://docker:2375
    # Desabilita TLS para a comunica√ß√£o interna com o dind
    DOCKER_TLS_CERTDIR: ""
    # Define uma tag est√°vel para ser usada como cache
    CACHE_IMAGE_TAG: "$CI_REGISTRY_IMAGE:latest"
  # ----------------------------------------

  before_script:
    - echo "--- Verificando o conte√∫do do Dockerfile no Runner ---"
    - cat Dockerfile | head -n 5
    - echo "----------------------------------------------------"

  script:
    - echo "Aguardando o servi√ßo Docker-in-Docker iniciar..."
    - sleep 15
    - echo "Fazendo login no GitLab Container Registry..."
    - echo "$CI_JOB_TOKEN" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"

    # --- IN√çCIO DA L√ìGICA DE CACHE ---

    - echo "Puxando a imagem mais recente para usar como cache..."
    # Usamos "|| true" para que o pipeline n√£o falhe se a imagem ainda n√£o existir (ex: primeira execu√ß√£o)
    - docker pull $CACHE_IMAGE_TAG || true
    
    - echo "Construindo a nova imagem usando o cache..."
    # A m√°gica acontece aqui com a flag --cache-from
    - docker build --cache-from $CACHE_IMAGE_TAG -t "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA" -t "$CACHE_IMAGE_TAG" .
    #- docker build -t "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA" .

    # --- FIM DA L√ìGICA DE CACHE ---

    - echo "Enviando as imagens para o Registry..."
    # Envia a imagem com a tag espec√≠fica do commit
    - docker push "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA"
    # Envia a imagem com a tag 'latest' para ser usada no pr√≥ximo build
    - docker push $CACHE_IMAGE_TAG


# # EST√ÅGIO 2: Fazer o deploy da imagem no servidor VPS
# deploy_production_cgb:
#   stage: deploy
#   tags:
#     - run-dind # Garanta que seu runner tenha essa tag
#   image: docker:20.10.16
  
#   services:
#     - name: docker:20.10.16-dind
#       alias: docker # O alias √© importante para o DOCKER_HOST
#       # Adiciona a flag para permitir a conex√£o HTTP com seu registry
#       command: ["--insecure-registry=gitlab.carvalima.com.br:5050"]
  
#   # --- SE√á√ÉO CR√çTICA QUE ESTAVA FALTANDO ---
#   variables:
#     # Aponta o cliente Docker para o servi√ßo 'dind' na rede
#     DOCKER_HOST: tcp://docker:2375
#     # Desabilita TLS para a comunica√ß√£o interna com o dind
#     DOCKER_TLS_CERTDIR: ""
#     # Define uma tag est√°vel para ser usada como cache
#     CACHE_IMAGE_TAG: "$CI_REGISTRY_IMAGE:latest"
#   # ----------------------------------------
  
#   # A URL do ambiente agora tamb√©m √© din√¢mica!
#   environment:
#     name: production
#     url: https://$SUB_DOMAIN_NAME.$DOMAIN_NAME_CGB

#   script: |
#       # --- COMANDO M√ÅGICO PARA CAPTURAR ERROS ---
#       set -e

#       echo "Iniciando deploy para o projeto: $CI_PROJECT_NAME"
      
#       # Configura√ß√£o do SSH
#       which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )
#       eval $(ssh-agent -s)
#       ssh-add <(echo "$SSH_PRIVATE_KEY")
#       mkdir -p ~/.ssh && chmod 700 ~/.ssh
#       ssh-keyscan $VPS_IP_CGB >> ~/.ssh/known_hosts && chmod 644 ~/.ssh/known_hosts
#       ssh -A $VPS_USER_CGB@$VPS_IP_CGB "
#         # 1. Passa as vari√°veis do GitLab para a sess√£o SSH remota
#         export CI_PROJECT_NAME=${CI_PROJECT_NAME}
#         export CI_SERVER_HOST=${CI_SERVER_HOST}
#         export CI_PROJECT_PATH=${CI_PROJECT_PATH}
#         export DOMAIN_NAME=${DOMAIN_NAME_CGB}
#         export SUB_DOMAIN_NAME=${SUB_DOMAIN_NAME}
#         export DEPLOY_TOKEN_USER=${DEPLOY_TOKEN_USER}
#         export DEPLOY_TOKEN_PASSWORD=${DEPLOY_TOKEN_PASSWORD}
        
#         # 2. Constr√≥i os nomes dinamicamente no servidor
#         TARGET_DIR=~/docker-stacks/\$CI_PROJECT_NAME
#         REPO_URL=git@\$CI_SERVER_HOST:\$CI_PROJECT_PATH.git
        
#         echo \"üöÄ Deploying project: \$CI_PROJECT_NAME\"
#         echo \"Target directory: \$TARGET_DIR\"
#         echo \"Repository URL: \$REPO_URL\"
  
#         # L√≥gica para clonar ou atualizar o reposit√≥rio
#         if [ -d \"\$TARGET_DIR\" ]; then
#           echo '‚úÖ Diret√≥rio existente. Atualizando...'
#           cd \"\$TARGET_DIR\"
#           git pull origin main
#         else
#           echo 'ü§î Diret√≥rio n√£o encontrado. Clonando o reposit√≥rio...'
#           git clone \"\$REPO_URL\" \"\$TARGET_DIR\"
#           cd \"\$TARGET_DIR\"
#         fi
        
#         echo '--- üìù Criando arquivo de configura√ß√£o .env.prod ---'
#         # Este bloco continua o mesmo, ele j√° usa as vari√°veis do GitLab
#         echo \"DEBUG=${DEBUG}\" > .env.prod
#         echo \"DOMAIN_NAME=${DOMAIN_NAME_CGB}\" >> .env.prod
#         echo \"SUB_DOMAIN_NAME=${SUB_DOMAIN_NAME}\" >> .env.prod
#         echo \"DB_NAME_APP=${DB_NAME_APP}\" >> .env.prod
#         echo \"DB_USER_APP=${DB_USER_APP}\" >> .env.prod
#         echo \"DB_PASSWORD_APP=${DB_PASSWORD_APP}\" >> .env.prod
#         echo \"DB_HOST_APP=${DB_HOST_APP}\" >> .env.prod
#         echo \"DB_PORT_APP=${DB_PORT_APP}\" >> .env.prod
#         echo \"SECRET_KEY_DJANGO_CARREGAMENTO=${SECRET_KEY_DJANGO_CARREGAMENTO}\" >> .env.prod
#         echo \"SSW_DOMINIO=${SSW_DOMINIO}\" >> .env.prod
#         echo \"SSW_CPF=${SSW_CPF}\" >> .env.prod
#         echo \"SSW_USUARIO=${SSW_USUARIO}\" >> .env.prod
#         echo \"SSW_SENHA=${SSW_SENHA}\" >> .env.prod
#         echo \"DJANGO_DEBUG=${DJANGO_DEBUG}\" >> .env.prod
#         echo \"SSW_UNIDADE=${SSW_UNIDADE}\" >> .env.prod
#         echo \"DJANGO_CRYPTOGRAPHY_KEY=${DJANGO_CRYPTOGRAPHY_KEY}\" >> .env.prod
#         echo \"CREDENTIALS_ENCRYPTION_KEY=${CREDENTIALS_ENCRYPTION_KEY}\" >> .env.prod
#         echo \"PG_HOST_CARVALIMA=${PG_HOST_CARVALIMA}\" >> .env.prod
#         echo \"PG_DBNAME_CARVALIMA=${PG_DBNAME_CARVALIMA}\" >> .env.prod
#         echo \"PG_USER_CARVALIMA=${PG_USER_CARVALIMA}\" >> .env.prod
#         echo \"PG_PASSWORD_CARVALIMA=${PG_PASSWORD_CARVALIMA}\" >> .env.prod
#         echo \"PG_SSLMODE_CARVALIMA=${PG_SSLMODE_CARVALIMA}\" >> .env.prod
#         echo \"PG_PORT_CARVALIMA=${PG_PORT_CARVALIMA}\" >> .env.prod
#         echo \"REDIS_URL=redis://redis_fotos_operacional:6379/1\" >> .env.prod
#         echo \"USER_ID=$(id -u)\" >> .env.prod
#         echo \"GROUP_ID=$(id -g)\" >> .env.prod
#         echo \"DJANGO_Q_CLUSTER_NAME=${DJANGO_Q_CLUSTER_NAME_CGB}\" >> .env.prod
#         echo \"CI_PROJECT_NAME=${CI_PROJECT_NAME}\" >> .env.prod
#         echo \"CI_SERVER_HOST=${CI_SERVER_HOST}\" >> .env.prod
#         echo \"CI_PROJECT_PATH=${CI_PROJECT_PATH}\" >> .env.prod
#         echo \"CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE}\" >> .env.prod
#         echo \"IMAGE_VERSION=${CI_COMMIT_SHORT_SHA}\" >> .env.prod
#         # ===============================================
#         # ===============================================
        
#         echo '--- üîë Autenticando no GitLab Registry ---'
#         echo \"${DEPLOY_TOKEN_PASSWORD}\" | docker login -u \"${DEPLOY_TOKEN_USER}\" --password-stdin $CI_REGISTRY
        
#         docker network create traefik || true
#         docker network create web_fotos_operacional || true

#         echo '--- üê≥ Fazendo deploy com Docker Compose ---'
#         export CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE
#         export IMAGE_VERSION=$CI_COMMIT_SHORT_SHA
        
#         # ---- L√ìGICA BLUE-GREEN ----

#         # 1. Converte o nome do projeto para min√∫sculas <-- CORRE√á√ÉO
#         CI_PROJECT_NAME_LOWER=\$(echo \"\$CI_PROJECT_NAME\" | tr '[:upper:]' '[:lower:]')


#         # 1. Determina qual √© a cor atual e qual ser√° a pr√≥xima
#         if \$(docker ps --format '{{.Names}}' | grep -q \"\${CI_PROJECT_NAME_LOWER}_blue\"); then
#             CURRENT_COLOR=\"blue\"
#             NEXT_COLOR=\"green\"
#         else
#             CURRENT_COLOR=\"green\" # Assume green como default se nenhum estiver rodando
#             NEXT_COLOR=\"blue\"
#         fi
        
#         echo \"üöÄ Vers√£o atual: \$CURRENT_COLOR. Pr√≥xima vers√£o: \$NEXT_COLOR\"
#         # 2. Sobe o novo ambiente (ex: green)
#         # A flag '-p' cria um 'projeto' Docker Compose separado, evitando conflitos.
#         echo \"--- ‚¨ÜÔ∏è  Iniciando a nova vers√£o (\$NEXT_COLOR) --- \"
#         docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} pull
#         docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} up -d --remove-orphans

#         # 3. VERIFICA√á√ÉO DE SA√öDE COM L√ìGICA DE ROLLBACK
#         echo \"--- ü©∫ Aguardando a nova vers√£o ficar online e saud√°vel... --- \"
#         HEALTH_CHECK_URL=\"https://\${SUB_DOMAIN_NAME}.$DOMAIN_NAME_CGB:8089\"
#         echo \"üìù HEALTH_CHECK LINK: \$HEALTH_CHECK_URL\"
        
#         n=0
#         HEALTHY=false
#         until [ \"\$n\" -ge 10 ]
#         do
#           if curl -s -f -k \"\$HEALTH_CHECK_URL\" > /dev/null; then
#             echo \"‚úÖ Aplica√ß√£o online e respondendo com sucesso!\"
#             HEALTHY=true
#             break
#           fi
          
#           n=\$((n+1)) 
#           echo \"Tentativa \$n/10 falhou. Aguardando 6 segundos...\"
#           sleep 6
#         done

#         # =========================================================================
#         # 4. DECIS√ÉO FINAL: PROSSEGUIR COM O DEPLOY OU FAZER ROLLBACK
#         # =========================================================================
#         if [ \"\$HEALTHY\" = true ]; then
#           # Health Check PASSOU: a nova vers√£o est√° boa.
#           # Removemos a vers√£o antiga e declaramos vit√≥ria.
#           echo \"--- üëç Health check bem-sucedido. Finalizando o deploy. --- \"
#           if [ \"\$CURRENT_COLOR\" != \"\$NEXT_COLOR\" ] && \$(docker ps --format '{{.Names}}' | grep -q \"\${CI_PROJECT_NAME_LOWER}_\${CURRENT_COLOR}\"); then
#               echo \"--- ‚¨áÔ∏è  Removendo a vers√£o antiga (\$CURRENT_COLOR) --- \"
#               docker compose -p \${CI_PROJECT_NAME_LOWER}_\${CURRENT_COLOR} down
#           fi
#           echo \"üéâ Deploy sem downtime conclu√≠do! Vers√£o \$NEXT_COLOR est√° no ar.\"
#         else
#           # Health Check FALHOU: a nova vers√£o est√° com problema.
#           # Fazemos o rollback e falhamos o pipeline.
#           echo \"‚ùå A nova vers√£o n√£o respondeu corretamente. Iniciando rollback autom√°tico...\"
          
#           echo \"--- Logs da vers√£o que falhou (\$NEXT_COLOR) para depura√ß√£o --- \"
#           docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} logs
          
#           echo \"--- ‚¨áÔ∏è  Derrubando a nova vers√£o que falhou (\$NEXT_COLOR) --- \"
#           docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} down
          
#           echo \"‚úÖ Rollback conclu√≠do. A vers√£o antiga (\$CURRENT_COLOR) continua no ar, intocada.\"
          
#           # Falha o pipeline explicitamente
#           exit 1
#         fi

#       "
#   only:
#     - main

# # EST√ÅGIO 2: Fazer o deploy da imagem no servidor VPS
# deploy_production_cgr:
#   stage: deploy
#   tags:
#     - run-cgr-dind # Garanta que seu runner tenha essa tag
#   image: docker:20.10.16
  
#   services:
#     - name: docker:20.10.16-dind
#       alias: docker # O alias √© importante para o DOCKER_HOST
#       # Adiciona a flag para permitir a conex√£o HTTP com seu registry
#       command: ["--insecure-registry=gitlab.carvalima.com.br:5050"]
  
#   # --- SE√á√ÉO CR√çTICA QUE ESTAVA FALTANDO ---
#   variables:
#     # Aponta o cliente Docker para o servi√ßo 'dind' na rede
#     DOCKER_HOST: tcp://docker:2375
#     # Desabilita TLS para a comunica√ß√£o interna com o dind
#     DOCKER_TLS_CERTDIR: ""
#     # Define uma tag est√°vel para ser usada como cache
#     CACHE_IMAGE_TAG: "$CI_REGISTRY_IMAGE:latest"
#   # ----------------------------------------
  
#   # A URL do ambiente agora tamb√©m √© din√¢mica!
#   environment:
#     name: production
#     url: https://$SUB_DOMAIN_NAME.$DOMAIN_NAME_CGR

#   script: |
#       # --- COMANDO M√ÅGICO PARA CAPTURAR ERROS ---
#       set -e

#       echo "Iniciando deploy para o projeto: $CI_PROJECT_NAME"
      
#       # Configura√ß√£o do SSH
#       which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )
#       eval $(ssh-agent -s)
#       ssh-add <(echo "$SSH_PRIVATE_KEY")
#       mkdir -p ~/.ssh && chmod 700 ~/.ssh
#       ssh-keyscan $VPS_IP_CGR >> ~/.ssh/known_hosts && chmod 644 ~/.ssh/known_hosts
#       ssh -A $VPS_USER_CGR@$VPS_IP_CGR "
#         # Adiciona a chave do host do GitLab ao known_hosts DENTRO do servidor remoto
#         mkdir -p ~/.ssh && chmod 700 ~/.ssh
#         ssh-keyscan ${CI_SERVER_HOST} >> ~/.ssh/known_hosts && chmod 644 ~/.ssh/known_hosts

#         # 1. Passa as vari√°veis do GitLab para a sess√£o SSH remota
#         export CI_PROJECT_NAME=${CI_PROJECT_NAME}
#         export CI_SERVER_HOST=${CI_SERVER_HOST}
#         export CI_PROJECT_PATH=${CI_PROJECT_PATH}
#         export DOMAIN_NAME=${DOMAIN_NAME_CGR}
#         export SUB_DOMAIN_NAME=${SUB_DOMAIN_NAME}
#         export DEPLOY_TOKEN_USER=${DEPLOY_TOKEN_USER}
#         export DEPLOY_TOKEN_PASSWORD=${DEPLOY_TOKEN_PASSWORD}
        
#         # 2. Constr√≥i os nomes dinamicamente no servidor
#         TARGET_DIR=~/docker-stacks/\$CI_PROJECT_NAME
#         REPO_URL=git@\$CI_SERVER_HOST:\$CI_PROJECT_PATH.git
        
#         echo \"üöÄ Deploying project: \$CI_PROJECT_NAME\"
#         echo \"Target directory: \$TARGET_DIR\"
#         echo \"Repository URL: \$REPO_URL\"
  
#         # L√≥gica para clonar ou atualizar o reposit√≥rio
#         if [ -d \"\$TARGET_DIR\" ]; then
#           echo '‚úÖ Diret√≥rio existente. Atualizando...'
#           cd \"\$TARGET_DIR\"
#           git pull origin main
#         else
#           echo 'ü§î Diret√≥rio n√£o encontrado. Clonando o reposit√≥rio...'
#           git clone \"\$REPO_URL\" \"\$TARGET_DIR\"
#           cd \"\$TARGET_DIR\"
#         fi
        
#         echo '--- üìù Criando arquivo de configura√ß√£o .env.prod ---'
#         # Este bloco continua o mesmo, ele j√° usa as vari√°veis do GitLab
#         echo \"DEBUG=${DEBUG}\" > .env.prod
#         echo \"DOMAIN_NAME=${DOMAIN_NAME_CGB}\" >> .env.prod
#         echo \"SUB_DOMAIN_NAME=${SUB_DOMAIN_NAME}\" >> .env.prod
#         echo \"DB_NAME_APP=${DB_NAME_APP}\" >> .env.prod
#         echo \"DB_USER_APP=${DB_USER_APP}\" >> .env.prod
#         echo \"DB_PASSWORD_APP=${DB_PASSWORD_APP}\" >> .env.prod
#         echo \"DB_HOST_APP=${DB_HOST_APP}\" >> .env.prod
#         echo \"DB_PORT_APP=${DB_PORT_APP}\" >> .env.prod
#         echo \"SECRET_KEY_DJANGO_CARREGAMENTO=${SECRET_KEY_DJANGO_CARREGAMENTO}\" >> .env.prod
#         echo \"SSW_DOMINIO=${SSW_DOMINIO}\" >> .env.prod
#         echo \"SSW_CPF=${SSW_CPF}\" >> .env.prod
#         echo \"SSW_USUARIO=${SSW_USUARIO}\" >> .env.prod
#         echo \"SSW_SENHA=${SSW_SENHA}\" >> .env.prod
#         echo \"DJANGO_DEBUG=${DJANGO_DEBUG}\" >> .env.prod
#         echo \"SSW_UNIDADE=${SSW_UNIDADE}\" >> .env.prod
#         echo \"DJANGO_CRYPTOGRAPHY_KEY=${DJANGO_CRYPTOGRAPHY_KEY}\" >> .env.prod
#         echo \"CREDENTIALS_ENCRYPTION_KEY=${CREDENTIALS_ENCRYPTION_KEY}\" >> .env.prod
#         echo \"PG_HOST_CARVALIMA=${PG_HOST_CARVALIMA}\" >> .env.prod
#         echo \"PG_DBNAME_CARVALIMA=${PG_DBNAME_CARVALIMA}\" >> .env.prod
#         echo \"PG_USER_CARVALIMA=${PG_USER_CARVALIMA}\" >> .env.prod
#         echo \"PG_PASSWORD_CARVALIMA=${PG_PASSWORD_CARVALIMA}\" >> .env.prod
#         echo \"PG_SSLMODE_CARVALIMA=${PG_SSLMODE_CARVALIMA}\" >> .env.prod
#         echo \"PG_PORT_CARVALIMA=${PG_PORT_CARVALIMA}\" >> .env.prod
#         echo \"REDIS_URL=redis://redis_fotos_operacional:6379/1\" >> .env.prod
#         echo \"USER_ID=$(id -u)\" >> .env.prod
#         echo \"GROUP_ID=$(id -g)\" >> .env.prod
#         echo \"DJANGO_Q_CLUSTER_NAME=${DJANGO_Q_CLUSTER_NAME_CGR}\" >> .env.prod
#         echo \"CI_PROJECT_NAME=${CI_PROJECT_NAME}\" >> .env.prod
#         echo \"CI_SERVER_HOST=${CI_SERVER_HOST}\" >> .env.prod
#         echo \"CI_PROJECT_PATH=${CI_PROJECT_PATH}\" >> .env.prod
#         echo \"CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE}\" >> .env.prod
#         echo \"IMAGE_VERSION=${CI_COMMIT_SHORT_SHA}\" >> .env.prod
#         # ===============================================
        
#         echo '--- üîë Autenticando no GitLab Registry ---'
#         echo \"${DEPLOY_TOKEN_PASSWORD}\" | docker login -u \"${DEPLOY_TOKEN_USER}\" --password-stdin $CI_REGISTRY
    
#         docker network create traefik || true
#         docker network create web_fotos_operacional || true
        
#         echo '--- üê≥ Fazendo deploy com Docker Compose ---'
#         export CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE
#         export IMAGE_VERSION=$CI_COMMIT_SHORT_SHA
        
#         # ---- L√ìGICA BLUE-GREEN ----

#         # 1. Converte o nome do projeto para min√∫sculas <-- CORRE√á√ÉO
#         CI_PROJECT_NAME_LOWER=\$(echo \"\$CI_PROJECT_NAME\" | tr '[:upper:]' '[:lower:]')


#         # 1. Determina qual √© a cor atual e qual ser√° a pr√≥xima
#         if \$(docker ps --format '{{.Names}}' | grep -q \"\${CI_PROJECT_NAME_LOWER}_blue\"); then
#             CURRENT_COLOR=\"blue\"
#             NEXT_COLOR=\"green\"
#         else
#             CURRENT_COLOR=\"green\" # Assume green como default se nenhum estiver rodando
#             NEXT_COLOR=\"blue\"
#         fi
        
#         echo \"üöÄ Vers√£o atual: \$CURRENT_COLOR. Pr√≥xima vers√£o: \$NEXT_COLOR\"
#         # 2. Sobe o novo ambiente (ex: green)
#         # A flag '-p' cria um 'projeto' Docker Compose separado, evitando conflitos.
#         echo \"--- ‚¨ÜÔ∏è  Iniciando a nova vers√£o (\$NEXT_COLOR) --- \"
#         docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} pull
#         docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} up -d --remove-orphans

#         # 3. VERIFICA√á√ÉO DE SA√öDE COM L√ìGICA DE ROLLBACK
#         echo \"--- ü©∫ Aguardando a nova vers√£o ficar online e saud√°vel... --- \"
#         HEALTH_CHECK_URL=\"https://\${SUB_DOMAIN_NAME}.$DOMAIN_NAME_CGR:8089\"
#         echo \"üìù HEALTH_CHECK LINK: \$HEALTH_CHECK_URL\"
        
#         n=0
#         HEALTHY=false
#         until [ \"\$n\" -ge 10 ]
#         do
#           if curl -s -f -k \"\$HEALTH_CHECK_URL\" > /dev/null; then
#             echo \"‚úÖ Aplica√ß√£o online e respondendo com sucesso!\"
#             HEALTHY=true
#             break
#           fi
          
#           n=\$((n+1)) 
#           echo \"Tentativa \$n/10 falhou. Aguardando 6 segundos...\"
#           sleep 6
#         done

#         # =========================================================================
#         # 4. DECIS√ÉO FINAL: PROSSEGUIR COM O DEPLOY OU FAZER ROLLBACK
#         # =========================================================================
#         if [ \"\$HEALTHY\" = true ]; then
#           # Health Check PASSOU: a nova vers√£o est√° boa.
#           # Removemos a vers√£o antiga e declaramos vit√≥ria.
#           echo \"--- üëç Health check bem-sucedido. Finalizando o deploy. --- \"
#           if [ \"\$CURRENT_COLOR\" != \"\$NEXT_COLOR\" ] && \$(docker ps --format '{{.Names}}' | grep -q \"\${CI_PROJECT_NAME_LOWER}_\${CURRENT_COLOR}\"); then
#               echo \"--- ‚¨áÔ∏è  Removendo a vers√£o antiga (\$CURRENT_COLOR) --- \"
#               docker compose -p \${CI_PROJECT_NAME_LOWER}_\${CURRENT_COLOR} down
#           fi
#           echo \"üéâ Deploy sem downtime conclu√≠do! Vers√£o \$NEXT_COLOR est√° no ar.\"
#         else
#           # Health Check FALHOU: a nova vers√£o est√° com problema.
#           # Fazemos o rollback e falhamos o pipeline.
#           echo \"‚ùå A nova vers√£o n√£o respondeu corretamente. Iniciando rollback autom√°tico...\"
          
#           echo \"--- Logs da vers√£o que falhou (\$NEXT_COLOR) para depura√ß√£o --- \"
#           docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} logs
          
#           echo \"--- ‚¨áÔ∏è  Derrubando a nova vers√£o que falhou (\$NEXT_COLOR) --- \"
#           docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} down
          
#           echo \"‚úÖ Rollback conclu√≠do. A vers√£o antiga (\$CURRENT_COLOR) continua no ar, intocada.\"
          
#           # Falha o pipeline explicitamente
#           exit 1
#         fi

#       "
#   only:
#     - main

# EST√ÅGIO 2: Fazer o deploy da imagem no servidor VPS
deploy_test:
  stage: deploy
  tags:
    - run-dind-test
  image: docker:20.10.16
  
  services:
    - name: docker:20.10.16-dind
      alias: docker # O alias √© importante para o DOCKER_HOST
      # Adiciona a flag para permitir a conex√£o HTTP com seu registry
      command: ["--insecure-registry=gitlab.carvalima.com.br:5050"]
  
  # --- SE√á√ÉO CR√çTICA QUE ESTAVA FALTANDO ---
  variables:
    # Aponta o cliente Docker para o servi√ßo 'dind' na rede
    DOCKER_HOST: tcp://docker:2375
    # Desabilita TLS para a comunica√ß√£o interna com o dind
    DOCKER_TLS_CERTDIR: ""
    # Define uma tag est√°vel para ser usada como cache
    CACHE_IMAGE_TAG: "$CI_REGISTRY_IMAGE:latest"
  # ----------------------------------------
  
  # A URL do ambiente agora tamb√©m √© din√¢mica!
  environment:
    name: production
    url: https://$SUB_DOMAIN_NAME.$DOMAIN_NAME_TESTE

  script: |
      # --- COMANDO M√ÅGICO PARA CAPTURAR ERROS ---
      set -e

      echo "Iniciando deploy para o projeto: $CI_PROJECT_NAME"
      
      # Configura√ß√£o do SSH
      which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )
      eval $(ssh-agent -s)
      ssh-add <(echo "$SSH_PRIVATE_KEY")
      mkdir -p ~/.ssh && chmod 700 ~/.ssh
      ssh-keyscan $VPS_IP_TESTE >> ~/.ssh/known_hosts && chmod 644 ~/.ssh/known_hosts
      ssh -A $VPS_USER_TESTE@$VPS_IP_TESTE "
        # Adiciona a chave do host do GitLab ao known_hosts DENTRO do servidor remoto
        mkdir -p ~/.ssh && chmod 700 ~/.ssh
        ssh-keyscan ${CI_SERVER_HOST} >> ~/.ssh/known_hosts && chmod 644 ~/.ssh/known_hosts

        # 1. Passa as vari√°veis do GitLab para a sess√£o SSH remota
        export CI_PROJECT_NAME=${CI_PROJECT_NAME}
        export CI_SERVER_HOST=${CI_SERVER_HOST}
        export CI_PROJECT_PATH=${CI_PROJECT_PATH}
        export DOMAIN_NAME=${DOMAIN_NAME_TESTE}
        export SUB_DOMAIN_NAME=${SUB_DOMAIN_NAME}
        export DEPLOY_TOKEN_USER=${DEPLOY_TOKEN_USER}
        export DEPLOY_TOKEN_PASSWORD=${DEPLOY_TOKEN_PASSWORD}
        
        # 2. Constr√≥i os nomes dinamicamente no servidor
        TARGET_DIR=~/docker-stacks/\$CI_PROJECT_NAME
        REPO_URL=git@\$CI_SERVER_HOST:\$CI_PROJECT_PATH.git
        
        echo \"üöÄ Deploying project: \$CI_PROJECT_NAME\"
        echo \"Target directory: \$TARGET_DIR\"
        echo \"Repository URL: \$REPO_URL\"
  
        # L√≥gica para clonar ou atualizar o reposit√≥rio
        if [ -d \"\$TARGET_DIR\" ]; then
          echo '‚úÖ Diret√≥rio existente. Atualizando...'
          cd \"\$TARGET_DIR\"
          git pull origin main
        else
          echo 'ü§î Diret√≥rio n√£o encontrado. Clonando o reposit√≥rio...'
          git clone \"\$REPO_URL\" \"\$TARGET_DIR\"
          cd \"\$TARGET_DIR\"
        fi
        
        echo '--- üìù Criando arquivo de configura√ß√£o .env.prod ---'
        # Este bloco continua o mesmo, ele j√° usa as vari√°veis do GitLab
        echo \"DEBUG=${DEBUG}\" > .env.prod
        echo \"DOMAIN_NAME=${DOMAIN_NAME_TESTE}\" >> .env.prod
        echo \"SUB_DOMAIN_NAME=${SUB_DOMAIN_NAME}\" >> .env.prod
        echo \"CI_PROJECT_NAME=${CI_PROJECT_NAME}\" >> .env.prod
        echo \"CI_SERVER_HOST=${CI_SERVER_HOST}\" >> .env.prod
        echo \"CI_PROJECT_PATH=${CI_PROJECT_PATH}\" >> .env.prod
        echo \"CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE}\" >> .env.prod
        echo \"IMAGE_VERSION=${CI_COMMIT_SHORT_SHA}\" >> .env.prod
        echo \"BITRIX_WEBHOOK_URL=${BITRIX_WEBHOOK_URL}\" >> .env.prod
        echo \"PG_CARVALIMA_HELPDESK_DBNAME=${PG_CARVALIMA_HELPDESK_DBNAME}\" >> .env.prod
        echo \"PG_BOTAPP_HOST=${PG_BOTAPP_HOST}\" >> .env.prod
        echo \"PG_BOTAPP_PASSWORD=${PG_BOTAPP_PASSWORD}\" >> .env.prod
        echo \"PG_BOTAPP_PORT=${PG_BOTAPP_PORT}\" >> .env.prod
        echo \"PG_BOTAPP_USER=${PG_BOTAPP_USER}\" >> .env.prod
        # ===============================================
        
        echo '--- üîë Autenticando no GitLab Registry ---'
        echo \"${DEPLOY_TOKEN_PASSWORD}\" | docker login -u \"${DEPLOY_TOKEN_USER}\" --password-stdin $CI_REGISTRY
    
        docker network create traefik || true
        docker network create web_fotos_operacional || true
        
        echo '--- üê≥ Fazendo deploy com Docker Compose ---'
        export CI_REGISTRY_IMAGE=$CI_REGISTRY_IMAGE
        export IMAGE_VERSION=$CI_COMMIT_SHORT_SHA
        
        # ---- L√ìGICA BLUE-GREEN ----

        # 1. Converte o nome do projeto para min√∫sculas <-- CORRE√á√ÉO
        CI_PROJECT_NAME_LOWER=\$(echo \"\$CI_PROJECT_NAME\" | tr '[:upper:]' '[:lower:]')


        # 1. Determina qual √© a cor atual e qual ser√° a pr√≥xima
        if \$(docker ps --format '{{.Names}}' | grep -q \"\${CI_PROJECT_NAME_LOWER}_blue\"); then
            CURRENT_COLOR=\"blue\"
            NEXT_COLOR=\"green\"
        else
            CURRENT_COLOR=\"green\" # Assume green como default se nenhum estiver rodando
            NEXT_COLOR=\"blue\"
        fi
        
        echo \"üöÄ Vers√£o atual: \$CURRENT_COLOR. Pr√≥xima vers√£o: \$NEXT_COLOR\"
        # 2. Sobe o novo ambiente (ex: green)
        # A flag '-p' cria um 'projeto' Docker Compose separado, evitando conflitos.
        echo \"--- ‚¨ÜÔ∏è  Iniciando a nova vers√£o (\$NEXT_COLOR) --- \"
        docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} pull
        docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} up -d --remove-orphans

        # 3. VERIFICA√á√ÉO DE SA√öDE COM L√ìGICA DE ROLLBACK
        echo \"--- ü©∫ Aguardando a nova vers√£o ficar online e saud√°vel... --- \"
        HEALTH_CHECK_URL=\"https://\${SUB_DOMAIN_NAME}.$DOMAIN_NAME_TESTE:8086\"
        echo \"üìù HEALTH_CHECK LINK: \$HEALTH_CHECK_URL\"
        
        n=0
        HEALTHY=false
        until [ \"\$n\" -ge 10 ]
        do
          if curl -s -f -k \"\$HEALTH_CHECK_URL\" > /dev/null; then
            echo \"‚úÖ Aplica√ß√£o online e respondendo com sucesso!\"
            HEALTHY=true
            break
          fi
          
          n=\$((n+1)) 
          echo \"Tentativa \$n/10 falhou. Aguardando 6 segundos...\"
          sleep 6
        done

        # =========================================================================
        # 4. DECIS√ÉO FINAL: PROSSEGUIR COM O DEPLOY OU FAZER ROLLBACK
        # =========================================================================
        if [ \"\$HEALTHY\" = true ]; then
          # Health Check PASSOU: a nova vers√£o est√° boa.
          # Removemos a vers√£o antiga e declaramos vit√≥ria.
          echo \"--- üëç Health check bem-sucedido. Finalizando o deploy. --- \"
          if [ \"\$CURRENT_COLOR\" != \"\$NEXT_COLOR\" ] && \$(docker ps --format '{{.Names}}' | grep -q \"\${CI_PROJECT_NAME_LOWER}_\${CURRENT_COLOR}\"); then
              echo \"--- ‚¨áÔ∏è  Removendo a vers√£o antiga (\$CURRENT_COLOR) --- \"
              docker compose -p \${CI_PROJECT_NAME_LOWER}_\${CURRENT_COLOR} down
          fi
          echo \"üéâ Deploy sem downtime conclu√≠do! Vers√£o \$NEXT_COLOR est√° no ar.\"
        else
          # Health Check FALHOU: a nova vers√£o est√° com problema.
          # Fazemos o rollback e falhamos o pipeline.
          echo \"‚ùå A nova vers√£o n√£o respondeu corretamente. Iniciando rollback autom√°tico...\"
          
          echo \"--- Logs da vers√£o que falhou (\$NEXT_COLOR) para depura√ß√£o --- \"
          docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} logs
          
          echo \"--- ‚¨áÔ∏è  Derrubando a nova vers√£o que falhou (\$NEXT_COLOR) --- \"
          docker compose -p \${CI_PROJECT_NAME_LOWER}_\${NEXT_COLOR} down
          
          echo \"‚úÖ Rollback conclu√≠do. A vers√£o antiga (\$CURRENT_COLOR) continua no ar, intocada.\"
          
          # Falha o pipeline explicitamente
          exit 1
        fi

      "
  only:
    - master