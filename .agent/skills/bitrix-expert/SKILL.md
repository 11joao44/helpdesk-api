---
name: bitrix-expert
description: Manages Bitrix24 CRM integration, handling webhooks, ID mapping, and network resilience.
version: 2.0
---

# Context

The backend acts as a gateway and orchestrator for Bitrix24. We sync Tickets (Deals) and Comments (Activities).

## 1. The "Golden Rule" of IDs (CRITICAL)

You must explicitly distinguish between the two types of IDs in the system. Mixing them causes data corruption.

- **Internal ID (`id`)**:
  - SOURCE: Generated by PostgreSQL.
  - USAGE: **MANDATORY** for Foreign Keys (DB relationships) and internal queries.
- **Bitrix ID (`deal_id`, `activity_id`)**:
  - SOURCE: From Bitrix24 API (e.g., `837`).
  - USAGE: Logs, External API calls, and **WebSocket Channels** (e.g., `ws/{bitrix_deal_id}`).
  - CONVENTION: Variable names should be explicit: `bitrix_deal_id` vs `internal_deal_id`.

## 2. Data Handling & Sanitization

- **Input**: When receiving data from Bitrix (Webhooks), map raw JSON to clean Pydantic Schemas immediately.
- **Output**: Never return "dirty" Bitrix JSON to the Frontend. Transform it into a frontend-friendly Schema.
- **Fields**: Use `app/core/constants.py` for custom field mapping (e.g., `UF_CRM_...`). Do not guess field IDs.

## 3. Resilience & Error Handling

- **Network Failures**: Assume Bitrix API might timeout. Wrap calls in try/except blocks handling `httpx.TimeoutError`.
- **Sync Logic**:
  - `ONCRMDEALADD/UPDATE` -> Updates local `DealRepository`.
  - `ONCRMACTIVITYADD` -> Updates local `ActivityRepository`.
  - **Attachments**: Implement "Dual Upload". Files must be uploaded to BOTH Bitrix Disk AND MinIO (S3).

## 4. Workflow Example

When creating a Ticket:

1. Validate input (Pydantic).
2. Call `BitrixProvider.create_deal()` -> Get `bitrix_id`.
3. Save to Local DB (`DealRepository`) using `bitrix_id` but generating a new `internal_id`.
4. Return the combined object.
